<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BRIDGE — PLUGIN</title>
    <style>
      :root {
        --bg: #ffffff;
        --fg: #000000;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-size: 12px;
      }
      main {
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      .status span {
        font-weight: 400;
        letter-spacing: 0.03em;
      }
      .status .linked {
        color: #00aa00;
      }
      .status .offline {
        color: #cc0000;
      }
      .log {
        padding: 4px 0;
        font-weight: 500;
        letter-spacing: 0.02em;
        min-height: auto;
      }
      .btn {
        background: var(--bg);
        color: var(--fg);
        border: 1px solid #000;
        height: 44px;
        font-family: inherit;
        font-size: inherit;
        letter-spacing: inherit;
        text-transform: inherit;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
      }
      .btn:hover {
        background: #000;
        color: #fff;
      }
      .icon-links {
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
      }
      .icon-btn {
        background: var(--bg);
        color: var(--fg);
        border: 1px solid #000;
        width: 24px;
        height: 24px;
        padding: 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s;
      }
      .icon-btn:hover {
        background: #000;
      }
      .icon-btn svg {
        width: 12px;
        height: 12px;
        fill: var(--fg);
        transition: fill 0.15s;
      }
      .icon-btn:hover svg {
        fill: #fff;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="top-bar">
        <div class="status">Server <span id="conn">CHECKING…</span></div>
        <div class="icon-links">
          <button class="icon-btn" onclick="window.open('https://x.com/naaaarukaru')" title="Follow on X">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
          </button>
          <button class="icon-btn" onclick="window.open('https://github.com/kingkongshot/Figma-Bridge')" title="Star on GitHub">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.463-1.11-1.463-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
            </svg>
          </button>
        </div>
      </div>
      <button class="btn" onclick="window.open('http://localhost:7788/index.html')">Open Preview</button>
    </main>

    <script>
      const server = 'http://localhost:7788';
      const connEl = document.getElementById('conn');

      async function ping() {
        try {
          const res = await fetch(server + '/health', { cache: 'no-store' });
          if (res.ok) {
            connEl.textContent = 'LINKED';
            connEl.className = 'linked';
          } else {
            throw new Error('bad status');
          }
        } catch (e) {
          connEl.textContent = 'OFFLINE';
          connEl.className = 'offline';
        }
      }

      // 简单的一次性导出等待器
      let pendingExportResolve = null;
      async function requestExportMissing(ids) {
        return new Promise((resolve) => {
          pendingExportResolve = resolve;
          parent.postMessage({ pluginMessage: { type: 'export-missing-images', ids } }, '*');
        });
      }

      // Request Figma native render (ground truth)
      let pendingPreviewResolve = null;
      async function requestFigmaRender() {
        return new Promise((resolve) => {
          pendingPreviewResolve = resolve;
          // 新事件名
          parent.postMessage({ pluginMessage: { type: 'export-figma-render' } }, '*');
        });
      }

      window.onmessage = async (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg) return;
        if (msg.type === 'send-composition') {
          const comp = msg.composition || null;
          const imageIds = Array.isArray(msg.imageIds) ? msg.imageIds : [];
          const hasChildren = comp && Array.isArray(comp.children) && comp.children.length > 0;
          if (hasChildren) {
            console.log('[UI] Received composition:', JSON.stringify(comp, null, 2).substring(0, 500));
          }
          if (!hasChildren) return; // 不再发送空 composition，避免 400 噪音
          try {
            // ============ 1) 图片缺失检查与增量上传 ============
            if (imageIds.length > 0) {
              let missing = imageIds;
              try {
                const resp = await fetch(server + '/api/images/check', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ ids: imageIds })
                });
                if (resp.ok) {
                  const data = await resp.json();
                  missing = Array.isArray(data && data.missing) ? data.missing : [];
                } else {
                  // 失败则保守视为全部缺失
                  missing = imageIds;
                }
              } catch (e) {
                console.warn('[UI] /api/images/check failed, fallback to full export', e);
                missing = imageIds;
              }

              if (missing.length > 0) {
                // 请求插件导出缺失图片
                const exportResult = await requestExportMissing(missing);
                const items = Array.isArray(exportResult && exportResult.items) ? exportResult.items : [];
                // 大批量时按块上传，避免超过服务器 25MB body 限制
                function chunk(arr, size) {
                  const out = [];
                  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
                  return out;
                }
                for (const batch of chunk(items, 50)) {
                  if (batch.length === 0) continue;
                  const resp = await fetch(server + '/api/images/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ items: batch })
                  });
                  if (!resp.ok) {
                    console.warn('[UI] /api/images/batch failed with status', resp.status);
                  }
                }
              }
            }
            // ============ 2) SVG 缺失检查与增量上传 ============
            try {
              // 收集插件侧已导出的 SVG 数据（svgId 已在插件侧通过 FNV-1a 计算完毕）
              // UI 侧只负责：检查缺失 → 上传 → 清理临时字段
              const svgItems = [];
              (function walk(n) {
                if (!n || n.visible === false) return;
                if (typeof n._svgContent === 'string' && typeof n.svgId === 'string' && n._svgContent) {
                  svgItems.push({ id: n.svgId, data: n._svgContent });
                }
                if (Array.isArray(n.children)) n.children.forEach(walk);
              })({ children: comp.children });
              const svgIds = Array.from(new Set(svgItems.map(x => x.id)));
              if (svgIds.length > 0) {
                const checkResp = await fetch(server + '/api/svgs/check', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ids: svgIds }) });
                let missingSvgIds = svgIds;
                if (checkResp.ok) {
                  const data = await checkResp.json();
                  missingSvgIds = Array.isArray(data && data.missing) ? data.missing : [];
                }
                if (missingSvgIds.length > 0) {
                  const toUpload = svgItems.filter(x => missingSvgIds.includes(x.id));
                  if (toUpload.length > 0) {
                    const uploadResp = await fetch(server + '/api/svgs/batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ items: toUpload }) });
                    if (!uploadResp.ok) {
                      console.error('[UI] svgs.batch failed:', uploadResp.status);
                    }
                  }
                }
              }
              // 清理临时 SVG 内容，随后直接发送 comp
              function cleanupSvgContent(n) {
                if (!n || typeof n !== 'object') return;
                delete n._svgContent;
                delete n.svgContent;
                if (Array.isArray(n.children)) n.children.forEach(cleanupSvgContent);
              }
              cleanupSvgContent({ children: comp.children });
            } catch (e) {
              console.warn('[UI] SVG upload/cleanup skipped:', e);
            }
            // Get Figma render first (for comparison)
            let figmaRender = null;
            try {
              const prev = await requestFigmaRender();
              const base64 = (prev && typeof prev.base64 === 'string') ? prev.base64 : '';
              if (base64 && base64.length > 0) {
                const MAX_BASE64_CHARS = 8_000_000; // ~6MB raw
                if (base64.length <= MAX_BASE64_CHARS) {
                  figmaRender = { base64 };
                } else {
                  console.warn('[UI] Figma render too large, skip');
                }
              }
            } catch (e) {
              // Figma render is optional
            }
            
            // Send composition with Figma render
            await fetch(server + '/api/composition', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                composition: comp,
                figmaRender: figmaRender
              })
            });
          } catch (e) {
            console.warn('[UI] Failed to send composition', e);
          }
        } else if (msg.type === 'export-missing-images:result') {
          if (typeof pendingExportResolve === 'function') {
            pendingExportResolve({ items: Array.isArray(msg.items) ? msg.items : [] });
            pendingExportResolve = null;
          }
        } else if (msg.type === 'export-figma-render:result') {
          if (typeof pendingPreviewResolve === 'function') {
            const base64 = (msg && typeof msg.base64 === 'string') ? msg.base64 : '';
            pendingPreviewResolve({ base64 });
            pendingPreviewResolve = null;
          }
        }
      };

      ping();
      setInterval(ping, 3000);
    </script>
  </body>
</html>
