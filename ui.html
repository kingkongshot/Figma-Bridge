<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BRIDGE — PLUGIN</title>
    <style>
      :root {
        --bg: #ffffff;
        --fg: #000000;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-size: 12px;
      }
      main {
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
      }
      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: 600;
      }
      .status span {
        font-weight: 400;
        letter-spacing: 0.03em;
      }
      .status .linked {
        color: #00aa00;
      }
      .status .offline {
        color: #cc0000;
      }
      .log {
        padding: 4px 0;
        font-weight: 500;
        letter-spacing: 0.02em;
        min-height: auto;
      }
      .btn {
        background: var(--bg);
        color: var(--fg);
        border: 1px solid #000;
        height: 44px;
        font-family: inherit;
        font-size: inherit;
        letter-spacing: inherit;
        text-transform: inherit;
        font-weight: 600;
        cursor: pointer;
        width: 100%;
      }
      .btn:hover {
        background: #000;
        color: #fff;
      }
      .icon-links {
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
      }
      .icon-btn {
        background: var(--bg);
        color: var(--fg);
        border: 1px solid #000;
        width: 24px;
        height: 24px;
        padding: 0;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s;
      }
      .icon-btn:hover {
        background: #000;
      }
      .icon-btn svg {
        width: 12px;
        height: 12px;
        fill: var(--fg);
        transition: fill 0.15s;
      }
      .icon-btn:hover svg {
        fill: #fff;
      }
    </style>
  </head>
  <body>
    <main>
      <div class="top-bar">
        <div class="status">Server <span id="conn">CHECKING…</span></div>
        <div class="icon-links">
          <button class="icon-btn" onclick="window.open('https://x.com/naaaarukaru')" title="Follow on X">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
          </button>
          <button class="icon-btn" onclick="window.open('https://github.com/kingkongshot/Figma-Bridge')" title="Star on GitHub">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.463-1.11-1.463-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
            </svg>
          </button>
        </div>
      </div>
      <button class="btn" onclick="window.open('http://localhost:7788/index.html')">Open Preview</button>
    </main>

    <script>
      const server = 'http://localhost:7788';
      const connEl = document.getElementById('conn');

      async function ping() {
        try {
          const res = await fetch(server + '/health', { cache: 'no-store' });
          if (res.ok) {
            connEl.textContent = 'LINKED';
            connEl.className = 'linked';
          } else {
            throw new Error('bad status');
          }
        } catch (e) {
          connEl.textContent = 'OFFLINE';
          connEl.className = 'offline';
        }
      }

      // 简单的一次性导出等待器
      let pendingExportResolve = null;
      async function requestExportMissing(ids) {
        return new Promise((resolve) => {
          pendingExportResolve = resolve;
          parent.postMessage({ pluginMessage: { type: 'export-missing-images', ids } }, '*');
        });
      }

      // SVG 导出等待器
      let pendingSvgExportResolve = null;
      async function requestExportMissingSvgs(nodeIds) {
        return new Promise((resolve) => {
          pendingSvgExportResolve = resolve;
          parent.postMessage({ pluginMessage: { type: 'export-missing-svgs', nodeIds } }, '*');
        });
      }

      // Request Figma native render (ground truth)
      let pendingPreviewResolve = null;
      async function requestFigmaRender() {
        return new Promise((resolve) => {
          pendingPreviewResolve = resolve;
          // 新事件名
          parent.postMessage({ pluginMessage: { type: 'export-figma-render' } }, '*');
        });
      }

      window.onmessage = async (event) => {
        const msg = event.data && event.data.pluginMessage;
        if (!msg) return;
        if (msg.type === 'send-composition') {
          const comp = msg.composition || null;
          const imageIds = Array.isArray(msg.imageIds) ? msg.imageIds : [];
          const hasChildren = comp && Array.isArray(comp.children) && comp.children.length > 0;
          if (hasChildren) {
            console.log('[UI] Received composition:', JSON.stringify(comp, null, 2).substring(0, 500));
          }
          if (!hasChildren) return; // 不再发送空 composition，避免 400 噪音
          try {
            // ============ 1) 图片缺失检查与增量上传 ============
            if (imageIds.length > 0) {
              let missing = imageIds;
              try {
                const resp = await fetch(server + '/api/images/check', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ ids: imageIds })
                });
                if (resp.ok) {
                  const data = await resp.json();
                  missing = Array.isArray(data && data.missing) ? data.missing : [];
                } else {
                  // 失败则保守视为全部缺失
                  missing = imageIds;
                }
              } catch (e) {
                console.warn('[UI] /api/images/check failed, fallback to full export', e);
                missing = imageIds;
              }

              if (missing.length > 0) {
                // 请求插件导出缺失图片
                const exportResult = await requestExportMissing(missing);
                const items = Array.isArray(exportResult && exportResult.items) ? exportResult.items : [];
                if (items.length > 0) {
                  await fetch(server + '/api/images/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ items })
                  });
                }
              }
            }
            // ============ 2) SVG 缺失检查与增量上传 ============
            try {
              // 收集 composition 中的 svgContent，计算稳定 svgId（FNV-1a + sanitize）
              function fnv1a(str) {
                let h = 2166136261 >>> 0;
                for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = Math.imul(h, 16777619) >>> 0; }
                return h.toString(36);
              }
              function sanitizeId(raw) { return String(raw || '').replace(/[^a-zA-Z0-9_-]/g, '_'); }
              const svgNodes = [];
              function walk(n) {
                if (!n || n.visible === false) return;
                if (typeof n.svgContent === 'string' && n.svgContent) {
                  const svgId = sanitizeId(fnv1a(n.svgContent));
                  console.log(`[UI] Found SVG node ${n.id}: svgId=${svgId}, content length=${n.svgContent.length}`);
                  svgNodes.push({ nodeId: n.id, svgId });
                } else if (n.type && ['VECTOR', 'POLYGON', 'STAR', 'ELLIPSE'].includes(n.type)) {
                  console.warn(`[UI] Vector node ${n.id} (${n.type}) has no svgContent!`);
                }
                if (Array.isArray(n.children)) n.children.forEach(walk);
              }
              (Array.isArray(comp.children) ? comp.children : []).forEach(walk);
              const svgIds = Array.from(new Set(svgNodes.map(x => x.svgId)));
              console.log(`[UI] Collected ${svgNodes.length} SVG nodes, ${svgIds.length} unique IDs`);
              if (svgIds.length > 0) {
                // 向服务器查询缺失 SVG
                let missingSvgIds = svgIds;
                try {
                  console.log(`[UI] Checking ${svgIds.length} SVG IDs with server...`);
                  const r = await fetch(server + '/api/svgs/check', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ids: svgIds })
                  });
                  if (r.ok) {
                    const data = await r.json();
                    missingSvgIds = Array.isArray(data && data.missing) ? data.missing : [];
                    console.log(`[UI] Server reports ${missingSvgIds.length} missing SVGs:`, missingSvgIds);
                  } else {
                    console.error(`[UI] SVG check failed: ${r.status}`);
                  }
                } catch (e) { 
                  console.error('[UI] SVG check error:', e);
                  missingSvgIds = svgIds; 
                }

                if (missingSvgIds.length > 0) {
                  // 选择需要导出的节点 id（nodeId 与 svgId 的映射在 svgNodes）
                  const exportNodeIds = svgNodes.filter(x => missingSvgIds.includes(x.svgId)).map(x => x.nodeId);
                  console.log(`[UI] Requesting export for ${exportNodeIds.length} nodes:`, exportNodeIds);
                  const exportResult = await requestExportMissingSvgs(exportNodeIds);
                  const items = Array.isArray(exportResult && exportResult.items) ? exportResult.items : [];
                  console.log(`[UI] Received ${items.length} exported SVG items`);
                  if (items.length > 0) {
                    console.log('[UI] Uploading SVGs to server...');
                    const uploadResp = await fetch(server + '/api/svgs/batch', {
                      method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ items })
                    });
                    if (uploadResp.ok) {
                      const uploadData = await uploadResp.json();
                      console.log('[UI] SVG upload result:', uploadData);
                    } else {
                      console.error(`[UI] SVG upload failed: ${uploadResp.status}`);
                    }
                  }
                } else {
                  console.log('[UI] All SVGs already exist on server');
                }

                // 用 svgId 替换 svgContent
                function rewrite(n) {
                  if (!n || n.visible === false) return;
                  if (typeof n.svgContent === 'string' && n.svgContent) {
                    const svgId = sanitizeId(fnv1a(n.svgContent));
                    n.svgId = svgId; delete n.svgContent;
                  }
                  if (Array.isArray(n.children)) n.children.forEach(rewrite);
                }
                (Array.isArray(comp.children) ? comp.children : []).forEach(rewrite);
              }
            } catch (e) {
              console.warn('[UI] SVG incremental upload failed or skipped:', e);
            }
            // Get Figma render first (for comparison)
            let figmaRender = null;
            try {
              const prev = await requestFigmaRender();
              const base64 = (prev && typeof prev.base64 === 'string') ? prev.base64 : '';
              if (base64 && base64.length > 0) {
                const MAX_BASE64_CHARS = 8_000_000; // ~6MB raw
                if (base64.length <= MAX_BASE64_CHARS) {
                  figmaRender = { base64 };
                } else {
                  console.warn('[UI] Figma render too large, skip');
                }
              }
            } catch (e) {
              // Figma render is optional
            }
            
            // Send composition with Figma render
            await fetch(server + '/api/composition', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                composition: comp,
                figmaRender: figmaRender
              })
            });
          } catch (e) {
            console.warn('[UI] Failed to send composition', e);
          }
        } else if (msg.type === 'export-missing-images:result') {
          if (typeof pendingExportResolve === 'function') {
            pendingExportResolve({ items: Array.isArray(msg.items) ? msg.items : [] });
            pendingExportResolve = null;
          }
        } else if (msg.type === 'export-missing-svgs:result') {
          if (typeof pendingSvgExportResolve === 'function') {
            pendingSvgExportResolve({ items: Array.isArray(msg.items) ? msg.items : [] });
            pendingSvgExportResolve = null;
          }
        } else if (msg.type === 'export-figma-render:result') {
          if (typeof pendingPreviewResolve === 'function') {
            const base64 = (msg && typeof msg.base64 === 'string') ? msg.base64 : '';
            pendingPreviewResolve({ base64 });
            pendingPreviewResolve = null;
          }
        }
      };

      ping();
      setInterval(ping, 3000);
    </script>
  </body>
</html>
